#pragma config(Sensor, in1,    otherBattery,   sensorAnalog)
#pragma config(Motor,  port1,           lmDrive,       tmotorVex393TurboSpeed_HBridge, openLoop, driveLeft)
#pragma config(Motor,  port2,           lin,           tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           l2,            tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           lfbDrive,      tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           l1,            tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           l3,            tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           rfbDrive,      tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           l4,            tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           rin,           tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          rmDrive,       tmotorVex393TurboSpeed_HBridge, openLoop, reversed, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(85)


#pragma systemFile
//ROBOTC Default Values: string = "", numbers = 536885932
#ifndef VOLTAGE_THRESHOLD
#include "battery.h"
#endif

#include "Vex_Competition_Includes.h"   //Main competition background code...do not modify!

void drive(const short left, const short right){
	if(abs(left) >= 30){
		motor[lfbDrive] = motor[lmDrive] = left; // sets all 3 left drive motors to left
	}
	else{
		motor[lfbDrive] = motor[lmDrive] = 0; // if power is less than 30, stop motors
	}
	if(abs(right) >= 30){
		motor[rfbDrive] = motor[rmDrive] = right; // sets all 3 right drive motors to right
	}
	else{
		motor[rfbDrive] = motor[rmDrive] = 0; // if power is less than 30, stop motors
	}
}

void intakeInDirection(const short dir){
	motor[lin] = motor[rin] = 127 * dir; // connects the intake motors to one function and the direction
}

void shootFly (int speed)
{
	motor[l1] = (speed);
	motor[l2] = (speed);
	motor[l3] = (speed);
	motor[l4] = (speed);
}

//Different default screen types, used by the displayScreen function in lcd.h to display a preconfigured screen
typedef enum _MHLCDScreenStyle{
	MHLCDScreenStyleColorSelection = 1,
	MHLCDScreenStylePointSelection = 2,
	MHLCDScreenStyleVoltage = 3,
	MHLCDScreenStyleOff = 0,
	MHLCDScreenStyleCustom = 4
}MHLCDScreenStyle;
//Map of the possible LCD button combinations to make them easy to reference
typedef enum _MHLCDButton{
	MHLCDButtonLeft = 1,
	MHLCDButtonCenter = 2,
	MHLCDButtonRight = 4,
	MHLCDButtonNone = 0
}MHLCDButton;
typedef struct MHLCDScreen{
	MHLCDScreenStyle style;
	MHLCDScreenStyle lastScreenStyle;
	MHLCDScreenStyle nextScreenStyle;
	string header;
	string footer;
	string topLine;
	string leftOption;
	string middleOption;
	string rightOption;
	string bottomLine;
	bool backlight;
}MHLCDScreen;
MHLCDScreen lastScreen;
MHLCDScreen nextScreen;
MHLCDScreen liveScreen;
//This sets up a screen based off of a default. It will operate on a custom screen, if a pointer to one is passed, but it defaults to nextScreen, if there is none passed.
void screenForScreenStyle(MHLCDScreenStyle style, MHLCDScreen *screen);
//This makes the passed screen go live on the VEX LCD. If both a header and a topLine is set, then the header will display. Same for the footer - bottomLine relationship
void displayScreen(MHLCDScreen screen);
//Displays a screen basec on a specified screen style
void displayScreenStyle(MHLCDScreenStyle style);
//This edits a string that is passed so that it will be centered within a given space. If no area is given, it will be centered to the VEX LCD
//void centerString(string *original, int area);
//Prepares a MHLCDScreen for display by the displayScreen function
void prepareScreen(MHLCDScreen *screen);
//Clears the LCD screen when necessary
void clearLCD();
//Halts program execution until all buttons on the VEX LCD are released
void waitForRelease();
void screenForScreenStyle(MHLCDScreenStyle style, MHLCDScreen *screen){
	if(!*screen){
		*screen = nextScreen;
	}
	screen->style = style;
	string header;
	string footer;
	switch(style){
		case MHLCDScreenStyleColorSelection:
			screen->style = MHLCDScreenStyleColorSelection;
			screen->lastScreenStyle = MHLCDScreenStylePointSelection;
			screen->nextScreenStyle = MHLCDScreenStyleVoltage;
			screen->backlight = true;
			screen->header = "Select Auton:";
			screen->topLine = header;
			screen->rightOption = "Reg";
			screen->middleOption = "None";
			screen->leftOption = "Block";
			screen->bottomLine = "Reg  None  Block";
			screen->footer = screen->bottomLine;
			break;
		case MHLCDScreenStylePointSelection:
			screen->style = MHLCDScreenStylePointSelection;
			screen->lastScreenStyle = MHLCDScreenStyleVoltage;
			screen->nextScreenStyle = MHLCDScreenStyleColorSelection;
			screen->backlight = true;
			screen->header = "Select Color:";
			screen->topLine = header;
			screen->leftOption = "RED";
			screen->middleOption = "Back";
			screen->rightOption = "BLUE";
			screen->bottomLine = "RED  Back   BLUE";
			screen->footer = screen->bottomLine;
			break;
		case MHLCDScreenStyleVoltage:
			screen->style = MHLCDScreenStyleVoltage;
			screen->lastScreenStyle = MHLCDScreenStyleOff;
			screen->nextScreenStyle = MHLCDScreenStylePointSelection;
			screen->backlight = false;
			screen->header = "2616F";
			screen->topLine = header;
			LCDVoltageLine(&footer);
			screen->footer = footer;
			screen->bottomLine = footer;
			break;
		case MHLCDScreenStyleOff:
			screen->style = MHLCDScreenStyleOff;
			screen->nextScreenStyle = MHLCDScreenStyleOff;
			screen->lastScreenStyle = MHLCDScreenStyleOff;
			screen->backlight = false;
			screen->header = "";
			screen->topLine = "";
			screen->footer = "";
			screen->bottomLine = "";
			break;
		case MHLCDScreenStyleCustom:
			screen->style = MHLCDScreenStyleCustom;
			screen->nextScreenStyle = MHLCDScreenStyleCustom;
			screen->lastScreenStyle = MHLCDScreenStyleCustom;
			screen->backlight = true;
			screen->header = "2616F";
			screen->topLine = "";
			screen->footer = "";
			screen->bottomLine = "";
		default:
			screen->style = MHLCDScreenStyleCustom;
			screen->nextScreenStyle = MHLCDScreenStyleCustom;
			screen->lastScreenStyle = MHLCDScreenStyleCustom;
			screen->backlight = true;
			screen->header = "2616F";
			screen->topLine = "";
			screen->footer = "";
			screen->bottomLine = "";
			break;
	}
		return;
}
void displayScreen(MHLCDScreen screen){
	prepareScreen(&screen);
	clearLCD();
	lastScreen = liveScreen;
	bLCDBacklight = screen.backlight;
	displayLCDCenteredString(0, screen.topLine);
	if(screen.style == MHLCDScreenStyleVoltage){
		displayLCDVoltageString(1);
	}
	else{
		displayLCDCenteredString(1, screen.bottomLine);
	}
	liveScreen = screen;
	screenForScreenStyle(screen.nextScreenStyle, &nextScreen);
}
void clearLCD(){
	clearLCDLine(0);
	clearLCDLine(1);
}
void prepareScreen(MHLCDScreen *screen){
	//These are all checking if the value is null, and assigning one, if it is. The probelm is that it might just be a null pointer. Pray that doesn't happen
	if(screen->backlight == NULL){
		screen->backlight = false;
	}
	if(screen->nextScreenStyle != MHLCDScreenStyleColorSelection || screen->nextScreenStyle != MHLCDScreenStylePointSelection || screen->nextScreenStyle != MHLCDScreenStyleVoltage || screen->nextScreenStyle != MHLCDScreenStyleOff){
		screen->nextScreenStyle = MHLCDScreenStyleCustom;
	}
	if(screen->lastScreenStyle != MHLCDScreenStyleColorSelection || screen->lastScreenStyle != MHLCDScreenStylePointSelection || screen->lastScreenStyle != MHLCDScreenStyleVoltage || screen->lastScreenStyle != MHLCDScreenStyleOff){
		screen->lastScreenStyle = MHLCDScreenStyleCustom;
	}
	if(screen->style != MHLCDScreenStyleColorSelection || screen->style != MHLCDScreenStylePointSelection || screen->style != MHLCDScreenStyleVoltage || screen->style != MHLCDScreenStyleOff){
		screen->style = MHLCDScreenStyleCustom;
	}
	if(screen->header != ""){
		screen->topLine = screen->header;
	}
	//if(screen->footer != ""){
	//	screen->bottomLine = screen->footer;
	//}
	//if(screen->rightOption != "" || screen->middleOption != "" || screen->leftOption != ""){
	//	if(strlen(screen->rightOption) + strlen(screen->middleOption) + strlen(screen->leftOption) <= 16){
	//		int space = MHLCDScreenWidth - strlen(screen->rightOption) + strlen(screen->leftOption);
	//		//centerString(screen->middleOption, space);
	//		sprintf(screen->bottomLine, "%s%s%s", screen->leftOption, screen->middleOption, screen->rightOption);
	//	}
	//	else{
	//		screen->bottomLine = "Too many chars";
	//	}
	//}
}
void waitForRelease(){
	while(nLCDButtons != MHLCDButtonNone){/*We just have to wait a while*/}
}
void displayScreenStyle(MHLCDScreenStyle style){
	MHLCDScreen screen;
	screenForScreenStyle(style, &screen);
	displayScreen(screen);
	if(style == MHLCDScreenStyleVoltage){
		bLCDBacklight = false;
		displayLCDVoltageString(1);
	}
}

MHLCDButton pressed[2] = {MHLCDButtonNone, MHLCDButtonNone};
/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton(){
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;
	do{
		pressed[0] = pressed[1] = MHLCDButtonNone;
		displayScreenStyle(MHLCDScreenStyleColorSelection);
		while(nLCDButtons != MHLCDButtonLeft && nLCDButtons != MHLCDButtonCenter && nLCDButtons != MHLCDButtonRight){}
		pressed[0] = (MHLCDButton)nLCDButtons;
		waitForRelease();
		if(pressed[0] == MHLCDButtonRight){
			displayScreenStyle(MHLCDScreenStylePointSelection);
			while(nLCDButtons != MHLCDButtonLeft && nLCDButtons != MHLCDButtonCenter && nLCDButtons != MHLCDButtonRight){}
			pressed[1] = (MHLCDButton)nLCDButtons;
			waitForRelease();
			if(pressed[1] == MHLCDButtonCenter){
				pressed[0] = pressed[1] = MHLCDButtonNone;
				continue;
			}
		}
	}while(pressed[0] == MHLCDButtonNone);
	displayScreenStyle(MHLCDScreenStyleVoltage);
}
/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Autonomous
//
/////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Autonomous
//													 Regular
//
//
//
//
//
//
//
//
//
/////////////////////////////////////////////////////////////////////////////////////////
task autonomous(){
	if(pressed[0] == MHLCDButtonLeft){
	displayScreenStyle(MHLCDScreenStyleVoltage);
	motor[rfbDrive] = -127; // drive backwards to hit bar infront of the net
	motor[lmDrive] = -127; // drive backwards to hit bar infront of the net
	motor[lfbDrive] = -127; // drive backwards to hit bar infront of the net
	motor[rmDrive] = -127; // drive backwards to hit bar infront of the net

	wait1Msec(3250); // drive backwards

	motor[rfbDrive] = 0; // set all drive = 0 so it stops
	motor[lmDrive] = 0; // set all drive = 0 so it stops
	motor[lfbDrive] = 0; // set all drive = 0 so it stops
	motor[rmDrive] = 0; // set all drive = 0 so it stops

	motor[l1] = 67; // rev launcher up to 67 power
	motor[l2] = 67; // rev launcher up to 67 power
	motor[l3] = 67; // rev launcher up to 67 power
	motor[l4] = 67; // rev launcher up to 67 power

	wait1Msec(3000); // ramp up launcher

	motor[lin] = -127; // outake for (400) Msec to launch first ball
	motor[rin] = -127; // outake for (400) Msec to launch first ball

	wait1Msec(400); // outake

	motor[lin] = 0; // stop outake
	motor[rin] = 0; // stop outake

	wait1Msec(250); // wait 1/4 second

	motor[lin] = -127; // outake second ball
	motor[rin] = -127; // outake second ball

	wait1Msec(700); // wait 7/10 of a second

	motor[lin] = 0; // stop outake
	motor[rin] = 0; // stop outake

	wait1Msec(250); // wait 1/4 second

	motor[lin] = -127; // outake
	motor[rin] = -127; // outake

	wait1Msec(700); // do it for 7/10 second

	motor[lin] = 0; // stop outake
	motor[rin] = 0; // stop outake

	wait1Msec(250); // wait again

	motor[lin] = -127; // outake
	motor[rin] = -127; // outake

	wait1Msec(1000);

	motor[lin] = 0; // stop outake
	motor[rin] = 0; // stop outake

	/////////////////////////////////////////////////////////////////////////////////////////
	//
	//                          Autonomous
	//													   RED
	//
	//
	//
	//
	//
	//
	//
	//
	//
	/////////////////////////////////////////////////////////////////////////////////////////

	}
	else if(pressed[0] == MHLCDButtonRight && pressed[1] == MHLCDButtonLeft){
		motor[rfbDrive] = -127; // drive backwards
		motor[lmDrive] = -127; // drive backwards
		motor[lfbDrive] = -127; // drive backwards
		motor[rmDrive] = -127; // drive backwards

		wait1Msec(500); // drive backwards

		motor[rfbDrive] = 0; // set all drive = 0 so it stops
		motor[lmDrive] = 0; // set all drive = 0 so it stops
		motor[lfbDrive] = 0; // set all drive = 0 so it stops
		motor[rmDrive] = 0; // set all drive = 0 so it stops

		wait1Msec(10); // mg

		motor[rfbDrive] = 127; // turn
		motor[lmDrive] = -127; //
		motor[lfbDrive] = -127; //
		motor[rmDrive] = 127; //

		wait1Msec(300);

		motor[rfbDrive] = 0; // set all drive = 0 so it stops
		motor[lmDrive] = 0; // set all drive = 0 so it stops
		motor[lfbDrive] = 0; // set all drive = 0 so it stops
		motor[rmDrive] = 0; // set all drive = 0 so it stops

		wait1Msec(10); // mg

		motor[rfbDrive] = -127; // drive backwards
		motor[lmDrive] = -127; // drive backwards
		motor[lfbDrive] = -127; // drive backwards
		motor[rmDrive] = -127; // drive backwards

		wait1Msec(2250); // drive backwards

		motor[rfbDrive] = 0; // set all drive = 0 so it stops
		motor[lmDrive] = 0; // set all drive = 0 so it stops
		motor[lfbDrive] = 0; // set all drive = 0 so it stops
		motor[rmDrive] = 0; // set all drive = 0 so it stops

		wait1Msec(10); // mg

		motor[rfbDrive] = -127; // turn other way
		motor[lmDrive] = 127; //
		motor[lfbDrive] = 127; //
		motor[rmDrive] = -127; //

		wait1Msec(250);

		motor[rfbDrive] = 0; // set all drive = 0 so it stops
		motor[lmDrive] = 0; // set all drive = 0 so it stops
		motor[lfbDrive] = 0; // set all drive = 0 so it stops
		motor[rmDrive] = 0; // set all drive = 0 so it stops

		wait1Msec(10); // mg

		motor[rfbDrive] = -127; // drive backwards
		motor[lmDrive] = -127; // drive backwards
		motor[lfbDrive] = -127; // drive backwards
		motor[rmDrive] = -127; // drive backwards

		wait1Msec(500); // drive backwards

		motor[rfbDrive] = 0; // set all drive = 0 so it stops
		motor[lmDrive] = 0; // set all drive = 0 so it stops
		motor[lfbDrive] = 0; // set all drive = 0 so it stops
		motor[rmDrive] = 0; // set all drive = 0 so it stops

		wait1Msec(10); // mg

		motor[rfbDrive] = -127; // drive right side ONLY backwards
		motor[rmDrive] = -127; // drive right side ONLY backwards

		wait1Msec(250); // drive backwards

		motor[rfbDrive] = 0; // set all drive = 0 so it stops
		motor[lmDrive] = 0; // set all drive = 0 so it stops
		motor[lfbDrive] = 0; // set all drive = 0 so it stops
		motor[rmDrive] = 0; // set all drive = 0 so it stops

		wait1Msec(10); // mg

		//////////////////
		//
		//		Launcher
		//
		//////////////////

		motor[l1] = 67; // rev launcher up to 67 power
		motor[l2] = 67; // rev launcher up to 67 power
		motor[l3] = 67; // rev launcher up to 67 power
		motor[l4] = 67; // rev launcher up to 67 power

		wait1Msec(3000); // ramp up launcher

		motor[lin] = -127; // outake for (400) Msec to launch first ball
		motor[rin] = -127; // outake for (400) Msec to launch first ball

		wait1Msec(400); // outake

		motor[lin] = 0; // stop outake
		motor[rin] = 0; // stop outake

		wait1Msec(500); // wait 1/2 second

		motor[lin] = -127; // outake second ball
		motor[rin] = -127; // outake second ball

		wait1Msec(700); // wait 7/10 of a second

		motor[lin] = 0; // stop outake
		motor[rin] = 0; // stop outake

		wait1Msec(500); // wait 1/2 second

		motor[lin] = -127; // outake
		motor[rin] = -127; // outake

		wait1Msec(700); // do it for 7/10 second

		motor[lin] = 0; // stop outake
		motor[rin] = 0; // stop outake

		wait1Msec(500); // wait again

		motor[lin] = -127; // outake
		motor[rin] = -127; // outake

		wait1Msec(1000); // turn intake off

		motor[lin] = 0; // stop outake
		motor[rin] = 0; // stop outake
	}

	/////////////////////////////////////////////////////////////////////////////////////////
	//
	//                          Autonomous
	//													   BLUE
	//
	//
	//
	//
	//
	//
	//
	//
	//
	/////////////////////////////////////////////////////////////////////////////////////////

	else if(pressed[0] == MHLCDButtonRight && pressed[1] == MHLCDButtonRight){
		motor[rfbDrive] = -127; // drive backwards
		motor[lmDrive] = -127; // drive backwards
		motor[lfbDrive] = -127; // drive backwards
		motor[rmDrive] = -127; // drive backwards

		wait1Msec(500); // drive backwards

		motor[rfbDrive] = 0; // set all drive = 0 so it stops
		motor[lmDrive] = 0; // set all drive = 0 so it stops
		motor[lfbDrive] = 0; // set all drive = 0 so it stops
		motor[rmDrive] = 0; // set all drive = 0 so it stops

	wait1Msec(10); // mg

	motor[rfbDrive] = -127; // turn
	motor[lmDrive] = 127; //
	motor[lfbDrive] = 127; //
	motor[rmDrive] = -127; //

	wait1Msec(300);

	motor[rfbDrive] = 0; // set all drive = 0 so it stops
	motor[lmDrive] = 0; // set all drive = 0 so it stops
	motor[lfbDrive] = 0; // set all drive = 0 so it stops
	motor[rmDrive] = 0; // set all drive = 0 so it stops

	wait1Msec(10); // mg

	motor[rfbDrive] = -127; // drive backwards
	motor[lmDrive] = -127; // drive backwards
	motor[lfbDrive] = -127; // drive backwards
	motor[rmDrive] = -127; // drive backwards

	wait1Msec(2250); // drive backwards

	motor[rfbDrive] = 0; // set all drive = 0 so it stops
	motor[lmDrive] = 0; // set all drive = 0 so it stops
	motor[lfbDrive] = 0; // set all drive = 0 so it stops
	motor[rmDrive] = 0; // set all drive = 0 so it stops

	wait1Msec(10); // mg

	motor[rfbDrive] = 127; // turn other way
	motor[lfbDrive] = -127; //
	motor[rmDrive] = 127; //

	wait1Msec(250);

	motor[rfbDrive] = 0; // set all drive = 0 so it stops
	motor[lmDrive] = 0; // set all drive = 0 so it stops
	motor[lfbDrive] = 0; // set all drive = 0 so it stops
	motor[rmDrive] = 0; // set all drive = 0 so it stops

	wait1Msec(10); // mg

	motor[rfbDrive] = -127; // drive backwards
	motor[lmDrive] = -127; // drive backwards
	motor[lfbDrive] = -127; // drive backwards
	motor[rmDrive] = -127; // drive backwards

	wait1Msec(500); // drive backwards

	motor[rfbDrive] = 0; // set all drive = 0 so it stops
	motor[lmDrive] = 0; // set all drive = 0 so it stops
	motor[lfbDrive] = 0; // set all drive = 0 so it stops
	motor[rmDrive] = 0; // set all drive = 0 so it stops

	wait1Msec(10); // mg

	motor[lfbDrive] = -127; // drive left side ONLY backwards
	motor[lmDrive] = -127; // drive left side ONLY backwards

	wait1Msec(250); // drive backwards

	motor[rfbDrive] = 0; // set all drive = 0 so it stops
	motor[lmDrive] = 0; // set all drive = 0 so it stops
	motor[lfbDrive] = 0; // set all drive = 0 so it stops
	motor[rmDrive] = 0; // set all drive = 0 so it stops

	wait1Msec(10); // mg

	//////////////////
	//
	//		Launcher
	//
	//////////////////

		motor[l1] = 67; // rev launcher up to 67 power
		motor[l2] = 67; // rev launcher up to 67 power
		motor[l3] = 67; // rev launcher up to 67 power
		motor[l4] = 67; // rev launcher up to 67 power

		wait1Msec(3000); // ramp up launcher

		motor[lin] = -127; // outake for (400) Msec to launch first ball
		motor[rin] = -127; // outake for (400) Msec to launch first ball

		wait1Msec(400); // outake

		motor[lin] = 0; // stop outake
		motor[rin] = 0; // stop outake

		wait1Msec(500); // wait 1/2 second

		motor[lin] = -127; // outake second ball
		motor[rin] = -127; // outake second ball

		wait1Msec(700); // wait 7/10 of a second

		motor[lin] = 0; // stop outake
		motor[rin] = 0; // stop outake

		wait1Msec(500); // wait 1/2 second

		motor[lin] = -127; // outake
		motor[rin] = -127; // outake

		wait1Msec(700); // do it for 7/10 second

		motor[lin] = 0; // stop outake
		motor[rin] = 0; // stop outake

		wait1Msec(500); // wait again

		motor[lin] = -127; // outake
		motor[rin] = -127; // outake

		wait1Msec(1000); // turn intake off

		motor[lin] = 0; // stop outake
		motor[rin] = 0; // stop outake
	}
	displayScreenStyle(MHLCDScreenStyleVoltage);
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
//////////////////////////////////////////////////////////////////////////////////////////
task usercontrol(){
	// User convtrol code here, inside the loop

	while (true){

	  drive(vexRT[Ch3], vexRT[Ch2]);
	  int dir = vexRT[Btn5U] ? 1 : vexRT[Btn5D] ? -1 : 0;
	  intakeInDirection(dir);
	  //dir = vexRT[Btn6U] ? 1 : vexRT[Btn6D] ? -1 : 0;
	  if (vexRT[Btn8L] == 1){
	  	shootFly(68);
	  }
	  else if (vexRT[Btn8U] == 1){
	  	shootFly(90);
	  }
		else if (vexRT[Btn8R] == 1){
			shootFly(100);
		}
		else if (vexRT[Btn8D] == 1){
			shootFly(127);
		}
	  else{
	  	shootFly(0);
	  }


	  //launchInDirection(dir);
	}
}
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/*
                                			2616F
																Frightening Lighting


												 ___      __    __     __    _______
											  |__ \    / /   /_ |   / /   |   ____|
  												 ) |  / /_    | |  / /_   |  |__
                          / /  | '_ \   | | | '_ \  |   __|
                         / /_  | (_) |  | | | (_) | |  |
                        |____|  \___/   |_|  \___/  |__|
*//
