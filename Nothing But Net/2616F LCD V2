#pragma config(Sensor, dgtl1,  killSwitch,     sensorTouch)
#pragma config(Sensor, dgtl2,  driveEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port1,           bottomIntake,  tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           leftBack,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           rightBack,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           leftDrive,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           angleOne,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           angleTwo,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           rightDrive,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           leftFront,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           rightFront,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          topIntake,     tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

// Wrap code with definition so it's not included more than once
#ifndef  _GETLCDBUTTONS
#define  _GETLCDBUTTONS

// Some utility strings
#define LEFT_ARROW  247
#define RIGHT_ARROW 246
static  char l_arr_str[4] = { LEFT_ARROW,  LEFT_ARROW,  LEFT_ARROW,  0};
static  char r_arr_str[4] = { RIGHT_ARROW, RIGHT_ARROW, RIGHT_ARROW, 0};

/*-----------------------------------------------------------------------------*/
/*  This function is used to get the LCD hutton status but also acts as a      */
/*  "wait for button release" feature.                                         */
/*  Use it in place of nLcdButtons.                                            */
/*  The function blocks until a button is pressed.                             */
/*-----------------------------------------------------------------------------*/

// Little macro to keep code cleaner, masks both disable/ebable and auton/driver
#define vexCompetitionState (nVexRCReceiveState & (vrDisabled | vrAutonomousMode))

TControllerButtons
getLcdButtons()
{
    TVexReceiverState   competitionState = vexCompetitionState;
    TControllerButtons  buttons;

    // This function will block until either
    // 1. A button is pressd on the LCD
    //    If a button is pressed when the function starts then that button
    //    must be released before a new button is detected.
    // 2. Robot competition state changes

    // Wait for all buttons to be released
    while( nLCDButtons != kButtonNone ) {
        // check competition state, bail if it changes
        if( vexCompetitionState != competitionState )
            return( kButtonNone );
        wait1Msec(10);
        }

    // block until an LCD button is pressed
    do  {
        // we use a copy of the lcd buttons to avoid their state changing
        // between the test and returning the status
        buttons = nLCDButtons;

        // check competition state, bail if it changes
        if( vexCompetitionState != competitionState )
            return( kButtonNone );

        wait1Msec(10);
        } while( buttons == kButtonNone );

    return( buttons );
}

#endif  // _GETLCDBUTTONS

static int MyAutonomous = 0;

/*-----------------------------------------------------------------------------*/
/*  Display autonomous selection                                               */
/*-----------------------------------------------------------------------------*/

void flyShoot(int speed)
{
	motor[leftFront] = speed;
	motor[leftBack] = speed;
	motor[rightFront] = speed;
	motor[rightBack] = speed;
}

void straightDrive(int speed)
{
	motor[rightDrive] = speed;
	motor[leftDrive] = speed;
}

void vertIntake(int speed)
{
	motor[bottomIntake] = speed;
}

void horizIntake(int speed)
{
	motor[topIntake] = speed;
}

void angleMeter(int speed)
{
	motor[angleOne] = speed;
	motor[angleTwo] = speed;
}

void LcdSetAutonomous( int value )
{
    // Simple selection display
    if( value == 0 ) {
        clearLCDLine(0);
        clearLCDLine(1);
    		wait1Msec(100);
    		displayLCDString(0, 0, "Full");
        displayLCDString(1, 0, " Yes   No    No ");
        }
    if( value == 1 ) {
        clearLCDLine(0);
        clearLCDLine(1);
    		wait1Msec(100);
    		displayLCDString(0, 0, "Half");
        displayLCDString(1, 0, " No   Yes   No  ");
        }
    if( value == 2 ) {
        clearLCDLine(0);
        clearLCDLine(1);
    		wait1Msec(100);
    		displayLCDString(0, 0, "FB LIH");
        displayLCDString(1, 0, " No    No   Yes ");
        }

    // Save autonomous mode for later
    MyAutonomous = value;
}

/*-----------------------------------------------------------------------------*/
/*  Select one of three autonomous choices                                     */
/*-----------------------------------------------------------------------------*/

void
LcdAutonomousSelection()
{
    TControllerButtons  button;

    // Clear LCD and turn on backlight
    clearLCDLine(0);
    clearLCDLine(1);
    bLCDBacklight = true;

    // diaplay default choice
    LcdSetAutonomous(0);

    while( bIfiRobotDisabled )
        {
        // this function blocks until button is pressed
        button = getLcdButtons();

        // Display and select the autonomous routine
        if( button == kButtonLeft )
            LcdSetAutonomous(0);

        if( button == kButtonCenter )
            LcdSetAutonomous(1);

        if( button == kButtonRight )
            LcdSetAutonomous(2);

        // Don't hog the cpu !
        wait1Msec(10);
        }


  }


void pre_auton()
{
   bStopTasksBetweenModes = true;

   LcdAutonomousSelection();
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
  switch( MyAutonomous ) {
        case    0:
            // run auton code
            break;

        case    1:
            // run some other auton code
            break;

        case    2:
            // run final auton case
        		break;

        default:
            break;
        }


        }




/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	// User control code here, inside the loop
  bLCDBacklight = true;									// Turn on LCD Backlight
	string mainBattery, backupBattery;

	while (true)
	{


	  clearLCDLine(0);											// Clear line 1 (0) of the LCD
		clearLCDLine(1);											// Clear line 2 (1) of the LCD

		//Display the Primary Robot battery voltage
		displayLCDString(0, 0, "Primary: ");
		sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
		displayNextLCDString(mainBattery);

		//Display the Backup battery voltage
		displayLCDString(1, 0, "Backup: ");
		sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0, 'V');	//Build the value to be displayed
		displayNextLCDString(backupBattery);

		//Short delay for the LCD refresh rate
		wait1Msec(100);

		// This code is for connor to drive
  motor[rightDrive] = vexRT(Ch2);
  motor[leftDrive] = vexRT(Ch1);

  // code for both connor and sammy to have outtake

  if(vexRT[Btn6U] == 1){
  	flyShoot(127);
  }
  else if(vexRT[Btn6D] == 1){
  	flyShoot(50);
  }
  else if(vexRT[Btn6UXmtr2] == 1){
  	flyShoot(127);
  }
  else if(vexRT[Btn6DXmtr2] == 1){
    flyShoot(50);
  }
  else{
  	flyShoot(0);
  }

  //code for intakes to run



  if(vexRT[Btn5D] == 1){
  	vertIntake(127);
  	horizIntake(70);
  }
  else if(vexRT[Btn5U] == 1){
  	vertIntake(-127);
  	horizIntake(-70);
  }
  else if(vexRT[Btn7DXmtr2] == 1){
  	vertIntake(127);
  	horizIntake(70);
  }
  else if(vexRT[Btn7LXmtr2] == 1){
  	vertIntake(-127);
  	horizIntake(-70);
  }
  else{
  	vertIntake(0);
  	horizIntake(0);
  }

  //code to run angles
  if(vexRT[Btn8D] == 1){
  	angleMeter(-63.5);
  }
  else if(vexRT[Btn8U] == 1){
  	angleMeter(63.5);
  }
  else if(vexRT[Btn8UXmtr2] == 1){
  	angleMeter(63.5);
  }
  else if(vexRT[Btn8DXmtr2] == 1){
  	angleMeter(-63.5);
  }
  else{
  	angleMeter(0);
  }





 }
}
