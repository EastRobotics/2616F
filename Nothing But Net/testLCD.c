#pragma config(Motor,  port1,           lmDrive,       tmotorVex393TurboSpeed_HBridge, openLoop, driveLeft)
#pragma config(Motor,  port2,           lin,           tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           l2,            tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           lfbDrive,      tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           l1,            tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           l3,            tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           rfbDrive,      tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           l4,            tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           rin,           tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          rmDrive,       tmotorVex393TurboSpeed_HBridge, openLoop, reversed, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(0)
#pragma userControlDuration(60)


#pragma systemFile
//ROBOTC Default Values: string = "", numbers = 536885932
#ifndef VOLTAGE_THRESHOLD
#include "battery.h"
#endif
#ifndef LCD
#define LCD
#endif



#include "Vex_Competition_Includes.h"   //Main competition background code...do not modify!

void drive(const short left, const short right){
	if(abs(left) >= 30){
		motor[lfbDrive] = motor[lmDrive] = left; // sets all 3 left drive motors to left
	}
	else{
		motor[lfbDrive] = motor[lmDrive] = 0; // if power is less than 30, stop motors
	}
	if(abs(right) >= 30){
		motor[rfbDrive] = motor[rmDrive] = right; // sets all 3 right drive motors to right
	}
	else{
		motor[rfbDrive] = motor[rmDrive] = 0; // if power is less than 30, stop motors
	}
}

void launchInDirection(const short dir){
	motor[l1] = motor[l2] = motor[l3] = motor[l4] = 127 * dir; // connects the launcher motors to one function and the direction
}

void intakeInDirection(const short dir){
	motor[lin] = motor[rin] = 127 * dir; // connects the intake motors to one function and the direction
}

void shootFly (int speed)
{
	motor[l1] = (speed);
	motor[l2] = (speed);
	motor[l3] = (speed);
	motor[l4] = (speed);
}

//Different default screen types, used by the displayScreen function in lcd.h to display a preconfigured screen
typedef enum _MHLCDScreenStyle{
	MHLCDScreenStyleColorSelection = 1,
	MHLCDScreenStylePointSelection = 2,
	MHLCDScreenStyleVoltage = 3,
	MHLCDScreenStyleOff = 0,
	MHLCDScreenStyleCustom = 4
}MHLCDScreenStyle;
//Map of the possible LCD button combinations to make them easy to reference
typedef enum _MHLCDButton{
	MHLCDButtonLeft = 1,
	MHLCDButtonCenter = 2,
	MHLCDButtonRight = 4,
	MHLCDButtonLeftCenter = 3,
	MHLCDButtonLeftRight = 5,
	MHLCDButtonCenterRight = 6,
	MHLCDButtonAll = 7,
	MHLCDButtonNone = 0
}MHLCDButton;
//Constant to denote a string to be centered to the LCD width in the centerString function
static const int MHStringPaddingLCDCenter = 0;
//At the time of this writing (December 3, 2014), the standard VEX LCD width is 16 charachters. This is a constant to make that more obvious. If that ever changes, this constant will have to, too
static const int MHLCDScreenWidth = 16;
typedef struct MHLCDScreen{
	MHLCDScreenStyle style;
	MHLCDScreenStyle lastScreenStyle;
	MHLCDScreenStyle nextScreenStyle;
	string header;
	string footer;
	string topLine;
	string leftOption;
	string middleOption;
	string rightOption;
	string bottomLine;
	bool backlight;
}MHLCDScreen;
MHLCDScreen lastScreen;
MHLCDScreen nextScreen;
MHLCDScreen liveScreen;
//This sets up a screen based off of a default. It will operate on a custom screen, if a pointer to one is passed, but it defaults to nextScreen, if there is none passed.
void screenForScreenStyle(MHLCDScreenStyle style, MHLCDScreen *screen);
//This makes the passed screen go live on the VEX LCD. If both a header and a topLine is set, then the header will display. Same for the footer - bottomLine relationship
void displayScreen(MHLCDScreen screen);
//Displays a screen basec on a specified screen style
void displayScreenStyle(MHLCDScreenStyle style);
//If it has a configuration, this makes the screen stored in nextScreen go live on the VEX LCD
void displayNextScreen();
//If it has a configuration, this makes the screen stroed in lastScreen go live on the VEX LCD
void displayLastScreen();
//This edits a string that is passed so that it will be centered within a given space. If no area is given, it will be centered to the VEX LCD
//void centerString(string *original, int area);
//Prepares a MHLCDScreen for display by the displayScreen function
void prepareScreen(MHLCDScreen *screen);
//Clears the LCD screen when necessary
void clearLCD();
//Prints a string to the first line of the LCD, and the second line, if a string for that line is specified
void print(const string lineOne, const string lineTwo);
//Checks to see if the buttons pressed are different from the ones passed in
bool otherButtonsPressed(MHLCDButton button);
//Halts program execution until a button is pressed on the VEX LCD, then waits an extra tenth of a second
void waitForPress();
//Halts program execution until all buttons on the VEX LCD are released
void waitForRelease();
//Displays a screen for 5 seconds, then switches back to the previous
void flashScreen(MHLCDScreen screen);
//Displays a screen style for 5 seconds, then switches back to the previous
void flashScreenStyle(MHLCDScreenStyle screenStyle);
//Waits for a specified amount of time (in seconds) while counting down the time on the LCD
void countDownForTime(MHTime time);
/*
void centerString(string *original, int area){
	string text = (string)*original;
	if(area == MHStringPaddingLCDCenter){
		area = MHLCDScreenWidth;
	}
	int space = area - strlen(text);
	string whitespace = "";
	for(int i = 0; i < floor(space / 2); i++){
			whitespace += " ";
	}
	if(space % 2 == 0){
		sprintf(*original, "%s%s%s", whitespace, text, whitespace);
	}
	else{
		sprintf(*original, "%s%s%s", whitespace, text, whitespace);
	}
}
*/
void screenForScreenStyle(MHLCDScreenStyle style, MHLCDScreen *screen){
	if(!*screen){
		*screen = nextScreen;
	}
	screen->style = style;
	string header;
	string footer;
	switch(style){
		case MHLCDScreenStyleColorSelection:
			screen->style = MHLCDScreenStyleColorSelection;
			screen->lastScreenStyle = MHLCDScreenStylePointSelection;
			screen->nextScreenStyle = MHLCDScreenStyleVoltage;
			screen->backlight = true;
			screen->header = "2616F";
			screen->topLine = header;
			screen->rightOption = "Regular";
			screen->middleOption = "None";
			screen->leftOption = "Block";
			screen->footer = "Regular  None  Block";
			screen->footer = screen->bottomLine;
			break;
		case MHLCDScreenStylePointSelection:
			screen->style = MHLCDScreenStylePointSelection;
			screen->lastScreenStyle = MHLCDScreenStyleVoltage;
			screen->nextScreenStyle = MHLCDScreenStyleColorSelection;
			screen->backlight = true;
			screen->header = "2616F";
			screen->topLine = header;
			screen->leftOption = "RED";
			screen->middleOption = "Back";
			screen->rightOption = "BLUE";
			screen->bottomLine = "RED  Back  BLUE";
			screen->footer = screen->bottomLine;
			break;
		case MHLCDScreenStyleVoltage:
			screen->style = MHLCDScreenStyleVoltage;
			screen->lastScreenStyle = MHLCDScreenStyleOff;
			screen->nextScreenStyle = MHLCDScreenStylePointSelection;
			screen->backlight = false;
			screen->header = "2616F";
			screen->topLine = header;
			LCDVoltageLine(&footer);
			screen->footer = footer;
			screen->bottomLine = footer;
			break;
		case MHLCDScreenStyleOff:
			screen->style = MHLCDScreenStyleOff;
			screen->nextScreenStyle = MHLCDScreenStyleOff;
			screen->lastScreenStyle = MHLCDScreenStyleOff;
			screen->backlight = false;
			screen->header = "";
			screen->topLine = "";
			screen->footer = "";
			screen->bottomLine = "";
			break;
		case MHLCDScreenStyleCustom:
			screen->style = MHLCDScreenStyleCustom;
			screen->nextScreenStyle = MHLCDScreenStyleCustom;
			screen->lastScreenStyle = MHLCDScreenStyleCustom;
			screen->backlight = true;
			screen->header = "2616F";
			screen->topLine = "";
			screen->footer = "";
			screen->bottomLine = "";
		default:
			screen->style = MHLCDScreenStyleCustom;
			screen->nextScreenStyle = MHLCDScreenStyleCustom;
			screen->lastScreenStyle = MHLCDScreenStyleCustom;
			screen->backlight = true;
			screen->header = "2616F";
			screen->topLine = "";
			screen->footer = "";
			screen->bottomLine = "";
			break;
	}
		return;
}
void displayScreen(MHLCDScreen screen){
	prepareScreen(&screen);
	clearLCD();
	lastScreen = liveScreen;
	bLCDBacklight = screen.backlight;
	displayLCDCenteredString(0, screen.topLine);
	if(screen.style == MHLCDScreenStyleVoltage){
		displayLCDVoltageString(1);
	}
	else{
		displayLCDCenteredString(1, screen.bottomLine);
	}
	liveScreen = screen;
	screenForScreenStyle(screen.nextScreenStyle, &nextScreen);
}
void clearLCD(){
	clearLCDLine(0);
	clearLCDLine(1);
}
void displayNextScreen(){
	if(liveScreen.nextScreenStyle){
		displayScreenStyle(liveScreen.nextScreenStyle);
	}
	else if(nextScreen){
		displayScreen(nextScreen);
	}
}
void displayLastScreen(){
	if(lastScreen){
		displayScreen(lastScreen);
	}
}
void prepareScreen(MHLCDScreen *screen){
	//These are all checking if the value is null, and assigning one, if it is. The probelm is that it might just be a null pointer. Pray that doesn't happen
	if(screen->backlight == NULL){
		screen->backlight = false;
	}
	if(screen->nextScreenStyle != MHLCDScreenStyleColorSelection || screen->nextScreenStyle != MHLCDScreenStylePointSelection || screen->nextScreenStyle != MHLCDScreenStyleVoltage || screen->nextScreenStyle != MHLCDScreenStyleOff){
		screen->nextScreenStyle = MHLCDScreenStyleCustom;
	}
	if(screen->lastScreenStyle != MHLCDScreenStyleColorSelection || screen->lastScreenStyle != MHLCDScreenStylePointSelection || screen->lastScreenStyle != MHLCDScreenStyleVoltage || screen->lastScreenStyle != MHLCDScreenStyleOff){
		screen->lastScreenStyle = MHLCDScreenStyleCustom;
	}
	if(screen->style != MHLCDScreenStyleColorSelection || screen->style != MHLCDScreenStylePointSelection || screen->style != MHLCDScreenStyleVoltage || screen->style != MHLCDScreenStyleOff){
		screen->style = MHLCDScreenStyleCustom;
	}
	if(screen->header != ""){
		screen->topLine = screen->header;
	}
	//if(screen->footer != ""){
	//	screen->bottomLine = screen->footer;
	//}
	//if(screen->rightOption != "" || screen->middleOption != "" || screen->leftOption != ""){
	//	if(strlen(screen->rightOption) + strlen(screen->middleOption) + strlen(screen->leftOption) <= 16){
	//		int space = MHLCDScreenWidth - strlen(screen->rightOption) + strlen(screen->leftOption);
	//		//centerString(screen->middleOption, space);
	//		sprintf(screen->bottomLine, "%s%s%s", screen->leftOption, screen->middleOption, screen->rightOption);
	//	}
	//	else{
	//		screen->bottomLine = "Too many chars";
	//	}
	//}
}
void print(const string lineOne, const string lineTwo){
	clearLCDLine(0);
	displayLCDPos(0, 0);
	displayNextLCDString(lineOne);
	if(lineTwo != ""){
		clearLCDLine(1);
		displayLCDPos(1, 0);
		displayNextLCDString(lineTwo);
	}
}
bool otherButtonsPressed(MHLCDButton button){
	if(nLCDButtons == button){
		return false;
	}
	else{
		return true;
	}
}
void waitForPress(){
	while(nLCDButtons == MHLCDButtonNone){/*We just have to wait a while*/}
	waitForRelease();
}
void waitForRelease(){
	while(nLCDButtons != MHLCDButtonNone){/*We just have to wait a while*/}
}
void waitForPressOfButton(MHLCDButton button){
	while(nLCDButtons != button){/*We just have to wait a while*/}
	waitForRelease();
}
void flashScreen(MHLCDScreen screen){
	displayScreen(screen);
	wait1Msec(5000);
	displayLastScreen();
}
void flashScreenStyle(MHLCDScreenStyle screenStyle){
	MHLCDScreen newScreen;
	screenForScreenStyle(screenStyle, &newScreen);
	flashScreen(newScreen);
}
void displayScreenStyle(MHLCDScreenStyle style){
	MHLCDScreen screen;
	screenForScreenStyle(style, &screen);
	displayScreen(screen);
	if(style == MHLCDScreenStyleVoltage){
		bLCDBacklight = false;
		displayLCDVoltageString(1);
	}
}
void countDownForTime(MHTime time){
	bool startState = bLCDBacklight;
	bLCDBacklight = true;
	for(int i = (int)(time/MHTimeOneSecond); i > 0; i++){
		string number;
		sprintf(number, "%d", i);
		displayLCDCenteredString(1, number);
		wait1Msec(MHTimeOneSecond);
	}
	bLCDBacklight = startState;
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton(){
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}
/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Autonomous
//
/////////////////////////////////////////////////////////////////////////////////////////


task autonomous()
{
	motor[rfbDrive] = -127; // drive backwards to hit bar infront of the net
	motor[lmDrive] = -127; // drive backwards to hit bar infront of the net
	motor[lfbDrive] = -127; // drive backwards to hit bar infront of the net
	motor[rmDrive] = -127; // drive backwards to hit bar infront of the net

	wait1Msec(3250); // drive backwards

	motor[rfbDrive] = 0; // set all drive = 0 so it stops
	motor[lmDrive] = 0; // set all drive = 0 so it stops
	motor[lfbDrive] = 0; // set all drive = 0 so it stops
	motor[rmDrive] = 0; // set all drive = 0 so it stops

	motor[l1] = 67; // rev launcher up to 67 power
	motor[l2] = 67; // rev launcher up to 67 power
	motor[l3] = 67; // rev launcher up to 67 power
	motor[l4] = 67; // rev launcher up to 67 power

	wait1Msec(3000); // ramp up launcher

	motor[lin] = -127; // outake for (400) Msec to launch first ball
	motor[rin] = -127; // outake for (400) Msec to launch first ball

	wait1Msec(400); // outake

	motor[lin] = 0; // stop outake
	motor[rin] = 0; // stop outake

	wait1Msec(250); // wait 1/4 second

	motor[lin] = -127; // outake second ball
	motor[rin] = -127; // outake second ball

	wait1Msec(700); // wait 7/10 of a second

	motor[lin] = 0; // stop outake
	motor[rin] = 0; // stop outake

	wait1Msec(250); // wait 1/4 second

	motor[lin] = -127; // outake
	motor[rin] = -127; // outake

	wait1Msec(700); // do it for 7/10 second

	motor[lin] = 0; // stop outake
	motor[rin] = 0; // stop outake

	wait1Msec(250); // wait again

	motor[lin] = -127; // outake
	motor[rin] = -127; // outake

	wait1Msec(1000);

	motor[lin] = 0; // stop outake
	motor[rin] = 0; // stop outake

}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
//////////////////////////////////////////////////////////////////////////////////////////
task usercontrol(){
	// User convtrol code here, inside the loop

	while (true){

	  drive(vexRT[Ch3], vexRT[Ch2]);
	  int dir = vexRT[Btn5U] ? 1 : vexRT[Btn5D] ? -1 : 0;
	  intakeInDirection(dir);
	  //dir = vexRT[Btn6U] ? 1 : vexRT[Btn6D] ? -1 : 0;
	  if (vexRT[Btn8L] == 1){
	  	shootFly(68);
	  }
	  else if (vexRT[Btn8U] == 1){
	  	shootFly(90);
	  }
		else if (vexRT[Btn8R] == 1){
			shootFly(100);
		}
		else if (vexRT[Btn8D] == 1){
			shootFly(127);
		}
	  else{
	  	shootFly(0);
	  }


	  //launchInDirection(dir);
	}
}
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/*
                                			2616F
																Frightening Lighting


												 ___      __    __     __    _______
											  |__ \    / /   /_ |   / /   |   ____|
  												 ) |  / /_    | |  / /_   |  |__
                          / /  | '_ \   | | | '_ \  |   __|
                         / /_  | (_) |  | | | (_) | |  |
                        |____|  \___/   |_|  \___/  |__|
*/
