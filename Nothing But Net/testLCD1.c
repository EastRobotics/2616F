#pragma config(Motor,  port1,           lmDrive,       tmotorVex393TurboSpeed_HBridge, openLoop, driveLeft)
#pragma config(Motor,  port2,           lin,           tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           l2,            tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           lfbDrive,      tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           l1,            tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           l3,            tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           rfbDrive,      tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           l4,            tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           rin,           tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          rmDrive,       tmotorVex393TurboSpeed_HBridge, openLoop, reversed, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(85)

/*
                                			2616F
																Frightening Lighting

												 ___      __    __     __    _______
											  |__ \    / /   /_ |   / /   |   ____|
  												 ) |  / /_    | |  / /_   |  |__
                          / /  | '_ \   | | | '_ \  |   __|
                         / /_  | (_) |  | | | (_) | |  |
                        |____|  \___/   |_|  \___/  |__|
*/

//ROBOTC Default Values: string = "", numbers = 536885932
#ifndef VOLTAGE_THRESHOLD
//We need access to Conrad's battery library, so we need to include it, if it hasn't been already
#include "battery.h"
#endif

//This is the minimum threshold for what speed a motor can run
#define MH_MINIMUM_MOTOR_POWER_THRESHOLD (30)

#include "Vex_Competition_Includes.h"   //Main competition background code...do not modify!

/* Sets the proper motors to the specified speeds

short left: The requested speed of the left side drive
short right: The requested speed of the right side drive

Called like: drive(127, 127); */
void drive(const short left, const short right){
	//Check to make sure that the requested left side power isn't too low
	if(abs(left) >= MH_MINIMUM_MOTOR_POWER_THRESHOLD){
		//If not, make the left side motors run at the requested left side power
		motor[lfbDrive] = motor[lmDrive] = left;
	}
	else{
		//If it is, just stop the left side motors
		motor[lfbDrive] = motor[lmDrive] = 0;
	}
	//Check to make sure that the requested right side power isn't too low
	if(abs(right) >= MH_MINIMUM_MOTOR_POWER_THRESHOLD){
		//If not, make the right side motors run at the requested right side power
		motor[rfbDrive] = motor[rmDrive] = right;
	}
	else{
		//If it is, just stop the left side motors
		motor[rfbDrive] = motor[rmDrive] = 0;
	}
}

/* Runs the intake motors in the specified direction

short dir: The direction the intake motors should run. 1 is forward, -1 is backward, 0 is stopped

Called like: intakeInDirection(1); */
void intakeInDirection(short dir){
	//Check to see if the direction is backward
	if(dir < 0){
		//If it is, set it to -1, so programmer error won't have an effect on the math
		dir = -1;
	}
	//If it's not backward, check to see if it's forward
	else if(dir > 0){
		//If it is, set it to 1, so programmer error won't have an effect on the math
		dir = 1;
	}
	//Finally, make the intake motors run as fast as they can in the specified direction
	motor[lin] = motor[rin] = 127 * dir;
}

void shootFly(const int speed){
	motor[l1] = motor[l2] = motor[l3] = motor[l4] = speed;
}

//Different default screen types, used by the displayScreen function in lcd.h to display a preconfigured screen
typedef enum _MHLCDScreenStyle{
	MHLCDScreenStyleColorSelection,
	MHLCDScreenStylePointSelection,
	MHLCDScreenStyleVoltage,
	MHLCDScreenStyleOff,
	MHLCDScreenStyleCustom
}MHLCDScreenStyle;
//Bitmask of the possible LCD button combinations to make them easy to reference. You can combine these with the bitwise OR operator, the vertical bar ( | )
typedef enum _MHLCDButton{
	//The left button on the LCD
	MHLCDButtonLeft = 1,
	//The middle button on the LCD
	MHLCDButtonCenter = (1 << 1),
	//The right button on the LCD
	MHLCDButtonRight = (1 << 2),
	//Represents the state where no buttons are pressed on the LCD
	MHLCDButtonNone = 0
}MHLCDButton;
//Structure to represent the LCD and what it should be displaying
typedef struct MHLCDScreen{
	//The preconfigured style of the LCD screen, if it was configured with one
	MHLCDScreenStyle style;
	//The style of the last screen that was displayed, if there was one
	MHLCDScreenStyle lastScreenStyle;
	//The logical next screen that should be displayed. This is included for legacy purposes, but should not be used now
	MHLCDScreenStyle nextScreenStyle;
	//What should be displayed on the top line of the LCD
	string header;
	//What should be displayed on the middle line of the LCD
	string footer;
	//Same as MHLCDScreen.header, but this must be 16 charachters long to take up the full line
	string topLine;
	//The string that should be displayed above the left LCD button
	string leftOption;
	//The string that should be displayed above the middle LCD button
	string middleOption;
	//The string that should be displayed above the right LCD button
	string rightOption;
	//Same as MHLCDScreen.footer, but this must be 16 characters long to take up the full line
	string bottomLine;
	//Indicates if the backlight should be on
	bool backlight;
}MHLCDScreen;
//The last screen that was displayed on the LCD
MHLCDScreen lastScreen;
//The next screen that will be displayed on the LCD
MHLCDScreen nextScreen;
//The screen that is currently being displayed on the LCD
MHLCDScreen liveScreen;
//Displays a screen basec on a specified screen style
void displayScreenStyle(MHLCDScreenStyle style);
//Prepares a MHLCDScreen for display by the displayScreen function
void prepareScreen(MHLCDScreen *screen);
//Clears the LCD screen when necessary
void clearLCD();
//Halts program execution until all buttons on the VEX LCD are released
void waitForRelease();
//This sets up a screen based off of a default. It will operate on a custom screen, if a pointer to one is passed, but it defaults to nextScreen, if there is none passed.
void screenForScreenStyle(MHLCDScreenStyle style, MHLCDScreen *screen){
	if(!*screen){
		*screen = nextScreen;
	}
	screen->style = style;
	string header;
	string footer;
	switch(style){
		case MHLCDScreenStyleColorSelection:
			screen->style = MHLCDScreenStyleColorSelection;
			screen->lastScreenStyle = MHLCDScreenStylePointSelection;
			screen->nextScreenStyle = MHLCDScreenStyleVoltage;
			screen->backlight = true;
			screen->header = "Select Auton:";
			screen->topLine = header;
			screen->rightOption = "Reg";
			screen->middleOption = "None";
			screen->leftOption = "Block";
			screen->bottomLine = "Reg  None  Block";
			screen->footer = screen->bottomLine;
			break;
		case MHLCDScreenStylePointSelection:
			screen->style = MHLCDScreenStylePointSelection;
			screen->lastScreenStyle = MHLCDScreenStyleVoltage;
			screen->nextScreenStyle = MHLCDScreenStyleColorSelection;
			screen->backlight = true;
			screen->header = "Select Color:";
			screen->topLine = header;
			screen->leftOption = "RED";
			screen->middleOption = "Back";
			screen->rightOption = "BLUE";
			screen->bottomLine = "RED  Back   BLUE";
			screen->footer = screen->bottomLine;
			break;
		case MHLCDScreenStyleVoltage:
			screen->style = MHLCDScreenStyleVoltage;
			screen->lastScreenStyle = MHLCDScreenStyleOff;
			screen->nextScreenStyle = MHLCDScreenStylePointSelection;
			screen->backlight = false;
			screen->header = "2616F";
			screen->topLine = header;
			LCDVoltageLine(&footer);
			screen->footer = footer;
			screen->bottomLine = footer;
			break;
		case MHLCDScreenStyleOff:
			screen->style = MHLCDScreenStyleOff;
			screen->nextScreenStyle = MHLCDScreenStyleOff;
			screen->lastScreenStyle = MHLCDScreenStyleOff;
			screen->backlight = false;
			screen->header = "";
			screen->topLine = "";
			screen->footer = "";
			screen->bottomLine = "";
			break;
		case MHLCDScreenStyleCustom:
			screen->style = MHLCDScreenStyleCustom;
			screen->nextScreenStyle = MHLCDScreenStyleCustom;
			screen->lastScreenStyle = MHLCDScreenStyleCustom;
			screen->backlight = true;
			screen->header = "2616F";
			screen->topLine = "";
			screen->footer = "";
			screen->bottomLine = "";
		default:
			screen->style = MHLCDScreenStyleCustom;
			screen->nextScreenStyle = MHLCDScreenStyleCustom;
			screen->lastScreenStyle = MHLCDScreenStyleCustom;
			screen->backlight = true;
			screen->header = "2616F";
			screen->topLine = "";
			screen->footer = "";
			screen->bottomLine = "";
			break;
	}
		return;
}
//This makes the passed screen go live on the VEX LCD. If both a header and a topLine is set, then the header will display. Same for the footer - bottomLine relationship
void displayScreen(MHLCDScreen screen){
	prepareScreen(&screen);
	clearLCD();
	lastScreen = liveScreen;
	bLCDBacklight = screen.backlight;
	displayLCDCenteredString(0, screen.topLine);
	if(screen.style == MHLCDScreenStyleVoltage){
		displayLCDVoltageString(1);
	}
	else{
		displayLCDCenteredString(1, screen.bottomLine);
	}
	liveScreen = screen;
	screenForScreenStyle(screen.nextScreenStyle, &nextScreen);
}
void clearLCD(){
	clearLCDLine(0);
	clearLCDLine(1);
}
void prepareScreen(MHLCDScreen *screen){
	//These are all checking if the value is null, and assigning one, if it is. The probelm is that it might just be a null pointer. Pray that doesn't happen
	if(screen->backlight == NULL){
		screen->backlight = false;
	}
	if(screen->nextScreenStyle != MHLCDScreenStyleColorSelection || screen->nextScreenStyle != MHLCDScreenStylePointSelection || screen->nextScreenStyle != MHLCDScreenStyleVoltage || screen->nextScreenStyle != MHLCDScreenStyleOff){
		screen->nextScreenStyle = MHLCDScreenStyleCustom;
	}
	if(screen->lastScreenStyle != MHLCDScreenStyleColorSelection || screen->lastScreenStyle != MHLCDScreenStylePointSelection || screen->lastScreenStyle != MHLCDScreenStyleVoltage || screen->lastScreenStyle != MHLCDScreenStyleOff){
		screen->lastScreenStyle = MHLCDScreenStyleCustom;
	}
	if(screen->style != MHLCDScreenStyleColorSelection || screen->style != MHLCDScreenStylePointSelection || screen->style != MHLCDScreenStyleVoltage || screen->style != MHLCDScreenStyleOff){
		screen->style = MHLCDScreenStyleCustom;
	}
	if(screen->header != ""){
		screen->topLine = screen->header;
	}
	//if(screen->footer != ""){
	//	screen->bottomLine = screen->footer;
	//}
	//if(screen->rightOption != "" || screen->middleOption != "" || screen->leftOption != ""){
	//	if(strlen(screen->rightOption) + strlen(screen->middleOption) + strlen(screen->leftOption) <= 16){
	//		int space = MHLCDScreenWidth - strlen(screen->rightOption) + strlen(screen->leftOption);
	//		//centerString(screen->middleOption, space);
	//		sprintf(screen->bottomLine, "%s%s%s", screen->leftOption, screen->middleOption, screen->rightOption);
	//	}
	//	else{
	//		screen->bottomLine = "Too many chars";
	//	}
	//}
}
void waitForRelease(){
	while(nLCDButtons != MHLCDButtonNone){/*We just have to wait a while*/}
}
void displayScreenStyle(MHLCDScreenStyle style){
	MHLCDScreen screen;
	screenForScreenStyle(style, &screen);
	displayScreen(screen);
	if(style == MHLCDScreenStyleVoltage){
		bLCDBacklight = false;
		displayLCDVoltageString(1);
	}
}
bool listening = false;
TSemaphore listeningLock;
task listenForLCDBack(){
	semaphoreLock(listeningLock);
	listening = true;
	if(bDoesTaskOwnSemaphore(listeningLock)){
		semaphoreUnlock(listeningLock);
	}
	while(nLCDButtons == MHLCDButtonNone){
		wait1Msec(50);
	}
	waitForRelease();
	listening = false;
	pre_auton();
}
MHLCDButton pressed[2] = {MHLCDButtonNone, MHLCDButtonNone};
/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton(){
	static bool lockInitialized = false;
	if(!lockInitialized){
		semaphoreInitialize(listeningLock);
	}
	semaphoreLock(listeningLock);
	if(listening){
		if(bDoesTaskOwnSemaphore(listeningLock)){
			semaphoreUnlock(listeningLock);
		}
		stopTask(listenForLCDBack);
	}
  bStopTasksBetweenModes = false;
	do{
		pressed[0] = pressed[1] = MHLCDButtonNone;
		displayScreenStyle(MHLCDScreenStyleColorSelection);
		while(nLCDButtons != MHLCDButtonLeft && nLCDButtons != MHLCDButtonCenter && nLCDButtons != MHLCDButtonRight){}
		pressed[0] = (MHLCDButton)nLCDButtons;
		waitForRelease();
		if(pressed[0] == MHLCDButtonRight){
			displayScreenStyle(MHLCDScreenStylePointSelection);
			while(nLCDButtons != MHLCDButtonLeft && nLCDButtons != MHLCDButtonCenter && nLCDButtons != MHLCDButtonRight){}
			pressed[1] = (MHLCDButton)nLCDButtons;
			waitForRelease();
			if(pressed[1] == MHLCDButtonCenter){
				pressed[0] = pressed[1] = MHLCDButtonNone;
				continue;
			}
		}
	}while(pressed[0] == MHLCDButtonNone);
	startTask(listenForLCDBack);
	displayScreenStyle(MHLCDScreenStyleVoltage);
}
/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Autonomous
//
/////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Autonomous
//													 Regular
//
//
//
//
//
//
//
//
//
/////////////////////////////////////////////////////////////////////////////////////////
task autonomous(){
	semaphoreLock(listeningLock);
	if(!listening){
		if(bDoesTaskOwnSemaphore(listeningLock)){
			semaphoreUnlock(listeningLock);
		}
		startTask(listenForLCDBack);
	}
	if(bDoesTaskOwnSemaphore(listeningLock)){
			semaphoreUnlock(listeningLock);
	}
	displayScreenStyle(MHLCDScreenStyleVoltage);
	displayLCDCenteredString(0, "Running Auton:");
	if(pressed[0] == MHLCDButtonLeft){
		displayLCDCenteredString(1, "Regular");
		motor[rfbDrive] = -127; // drive backwards to hit bar infront of the net
		motor[lmDrive] = -127; // drive backwards to hit bar infront of the net
		motor[lfbDrive] = -127; // drive backwards to hit bar infront of the net
		motor[rmDrive] = -127; // drive backwards to hit bar infront of the net

		wait1Msec(3250); // drive backwards

		motor[rfbDrive] = 0; // set all drive = 0 so it stops
		motor[lmDrive] = 0; // set all drive = 0 so it stops
		motor[lfbDrive] = 0; // set all drive = 0 so it stops
		motor[rmDrive] = 0; // set all drive = 0 so it stops

		wait1Msec(10); // take a break

		motor[l1] = 67; // rev launcher up to 67 power
		motor[l2] = 67; // rev launcher up to 67 power
		motor[l3] = 67; // rev launcher up to 67 power
		motor[l4] = 67; // rev launcher up to 67 power

		wait1Msec(3000); // ramp up launcher

		motor[lin] = -127; // outake for (400) Msec to launch first ball
		motor[rin] = -127; // outake for (400) Msec to launch first ball

		wait1Msec(300); // outake

		motor[lin] = 0; // stop outake
		motor[rin] = 0; // stop outake

		wait1Msec(500); // wait 1/2 second

		motor[lin] = -127; // outake second ball
		motor[rin] = -127; // outake second ball

		wait1Msec(300); // wait 7/10 of a second

		motor[lin] = 0; // stop outake
		motor[rin] = 0; // stop outake

		wait1Msec(500); // wait 1/2 second

		motor[lin] = -127; // outake
		motor[rin] = -127; // outake

		wait1Msec(300); // do it for 7/10 second

		motor[lin] = 0; // stop outake
		motor[rin] = 0; // stop outake

		wait1Msec(500); // wait again

		motor[lin] = -127; // outake
		motor[rin] = -127; // outake

		wait1Msec(1000); // turn intake off

		motor[lin] = 0; // stop outake
		motor[rin] = 0; // stop outake

	/////////////////////////////////////////////////////////////////////////////////////////
	//
	//                          Autonomous
	//													   RED
	//
	//
	//
	//
	//
	//
	//
	//
	//
	/////////////////////////////////////////////////////////////////////////////////////////

	}
	else if(pressed[0] == MHLCDButtonRight && pressed[1] == MHLCDButtonLeft){
		displayLCDCenteredString(1, "Red Block");
		motor[rfbDrive] = -127; // drive backwards
		motor[lmDrive] = -127; // drive backwards
		motor[lfbDrive] = -127; // drive backwards
		motor[rmDrive] = -127; // drive backwards

		wait1Msec(500); // drive backwards

		motor[rfbDrive] = 0; // set all drive = 0 so it stops
		motor[lmDrive] = 0; // set all drive = 0 so it stops
		motor[lfbDrive] = 0; // set all drive = 0 so it stops
		motor[rmDrive] = 0; // set all drive = 0 so it stops

		wait1Msec(10); // mg

		motor[rfbDrive] = 127; // turn
		motor[lmDrive] = -127; //
		motor[lfbDrive] = -127; //
		motor[rmDrive] = 127; //

		wait1Msec(300);

		motor[rfbDrive] = 0; // set all drive = 0 so it stops
		motor[lmDrive] = 0; // set all drive = 0 so it stops
		motor[lfbDrive] = 0; // set all drive = 0 so it stops
		motor[rmDrive] = 0; // set all drive = 0 so it stops

		wait1Msec(10); // mg

		motor[rfbDrive] = -127; // drive backwards
		motor[lmDrive] = -127; // drive backwards
		motor[lfbDrive] = -127; // drive backwards
		motor[rmDrive] = -127; // drive backwards

		wait1Msec(2250); // drive backwards

		motor[rfbDrive] = 0; // set all drive = 0 so it stops
		motor[lmDrive] = 0; // set all drive = 0 so it stops
		motor[lfbDrive] = 0; // set all drive = 0 so it stops
		motor[rmDrive] = 0; // set all drive = 0 so it stops

		wait1Msec(10); // mg

		motor[rfbDrive] = -127; // turn other way
		motor[lmDrive] = 127; //
		motor[lfbDrive] = 127; //
		motor[rmDrive] = -127; //

		wait1Msec(250);

		motor[rfbDrive] = 0; // set all drive = 0 so it stops
		motor[lmDrive] = 0; // set all drive = 0 so it stops
		motor[lfbDrive] = 0; // set all drive = 0 so it stops
		motor[rmDrive] = 0; // set all drive = 0 so it stops

		wait1Msec(10); // mg

		motor[rfbDrive] = -127; // drive backwards
		motor[lmDrive] = -127; // drive backwards
		motor[lfbDrive] = -127; // drive backwards
		motor[rmDrive] = -127; // drive backwards

		wait1Msec(500); // drive backwards

		motor[rfbDrive] = 0; // set all drive = 0 so it stops
		motor[lmDrive] = 0; // set all drive = 0 so it stops
		motor[lfbDrive] = 0; // set all drive = 0 so it stops
		motor[rmDrive] = 0; // set all drive = 0 so it stops

		wait1Msec(10); // mg

		motor[rfbDrive] = -127; // drive right side ONLY backwards
		motor[rmDrive] = -127; // drive right side ONLY backwards

		wait1Msec(250); // drive backwards

		motor[rfbDrive] = 0; // set all drive = 0 so it stops
		motor[lmDrive] = 0; // set all drive = 0 so it stops
		motor[lfbDrive] = 0; // set all drive = 0 so it stops
		motor[rmDrive] = 0; // set all drive = 0 so it stops

		wait1Msec(10); // mg

		//////////////////
		//
		//		Launcher
		//
		//////////////////

		motor[l1] = 67; // rev launcher up to 67 power
		motor[l2] = 67; // rev launcher up to 67 power
		motor[l3] = 67; // rev launcher up to 67 power
		motor[l4] = 67; // rev launcher up to 67 power

		wait1Msec(3000); // ramp up launcher

		motor[lin] = -127; // outake for (400) Msec to launch first ball
		motor[rin] = -127; // outake for (400) Msec to launch first ball

		wait1Msec(300); // outake

		motor[lin] = 0; // stop outake
		motor[rin] = 0; // stop outake

		wait1Msec(500); // wait 1/2 second

		motor[lin] = -127; // outake second ball
		motor[rin] = -127; // outake second ball

		wait1Msec(300); // wait 7/10 of a second

		motor[lin] = 0; // stop outake
		motor[rin] = 0; // stop outake

		wait1Msec(500); // wait 1/2 second

		motor[lin] = -127; // outake
		motor[rin] = -127; // outake

		wait1Msec(300); // do it for 7/10 second

		motor[lin] = 0; // stop outake
		motor[rin] = 0; // stop outake

		wait1Msec(500); // wait again

		motor[lin] = -127; // outake
		motor[rin] = -127; // outake

		wait1Msec(1000); // turn intake off

		motor[lin] = 0; // stop outake
		motor[rin] = 0; // stop outake
	}

	/////////////////////////////////////////////////////////////////////////////////////////
	//
	//                          Autonomous
	//													   BLUE
	//
	//
	//
	//
	//
	//
	//
	//
	//
	/////////////////////////////////////////////////////////////////////////////////////////

	else if(pressed[0] == MHLCDButtonRight && pressed[1] == MHLCDButtonRight){
		displayLCDCenteredString(1, "Blue Block");
		motor[rfbDrive] = -127; // drive backwards
		motor[lmDrive] = -127; // drive backwards
		motor[lfbDrive] = -127; // drive backwards
		motor[rmDrive] = -127; // drive backwards

		wait1Msec(500); // drive backwards

		motor[rfbDrive] = 0; // set all drive = 0 so it stops
		motor[lmDrive] = 0; // set all drive = 0 so it stops
		motor[lfbDrive] = 0; // set all drive = 0 so it stops
		motor[rmDrive] = 0; // set all drive = 0 so it stops

		wait1Msec(10); // mg

		motor[rfbDrive] = -127; // turn
		motor[lmDrive] = 127; //
		motor[lfbDrive] = 127; //
		motor[rmDrive] = -127; //

		wait1Msec(300);

		motor[rfbDrive] = 0; // set all drive = 0 so it stops
		motor[lmDrive] = 0; // set all drive = 0 so it stops
		motor[lfbDrive] = 0; // set all drive = 0 so it stops
		motor[rmDrive] = 0; // set all drive = 0 so it stops

		wait1Msec(10); // mg

		motor[rfbDrive] = -127; // drive backwards
		motor[lmDrive] = -127; // drive backwards
		motor[lfbDrive] = -127; // drive backwards
		motor[rmDrive] = -127; // drive backwards

		wait1Msec(2250); // drive backwards

		motor[rfbDrive] = 0; // set all drive = 0 so it stops
		motor[lmDrive] = 0; // set all drive = 0 so it stops
		motor[lfbDrive] = 0; // set all drive = 0 so it stops
		motor[rmDrive] = 0; // set all drive = 0 so it stops

		wait1Msec(10); // mg

		motor[rfbDrive] = 127; // turn other way
		motor[lfbDrive] = -127; //
		motor[rmDrive] = 127; //

		wait1Msec(250);

		motor[rfbDrive] = 0; // set all drive = 0 so it stops
		motor[lmDrive] = 0; // set all drive = 0 so it stops
		motor[lfbDrive] = 0; // set all drive = 0 so it stops
		motor[rmDrive] = 0; // set all drive = 0 so it stops

		wait1Msec(10); // mg

		motor[rfbDrive] = -127; // drive backwards
		motor[lmDrive] = -127; // drive backwards
		motor[lfbDrive] = -127; // drive backwards
		motor[rmDrive] = -127; // drive backwards

		wait1Msec(500); // drive backwards

		motor[rfbDrive] = 0; // set all drive = 0 so it stops
		motor[lmDrive] = 0; // set all drive = 0 so it stops
		motor[lfbDrive] = 0; // set all drive = 0 so it stops
		motor[rmDrive] = 0; // set all drive = 0 so it stops

		wait1Msec(10); // mg

		motor[lfbDrive] = -127; // drive left side ONLY backwards
		motor[lmDrive] = -127; // drive left side ONLY backwards

		wait1Msec(250); // drive backwards

		motor[rfbDrive] = 0; // set all drive = 0 so it stops
		motor[lmDrive] = 0; // set all drive = 0 so it stops
		motor[lfbDrive] = 0; // set all drive = 0 so it stops
		motor[rmDrive] = 0; // set all drive = 0 so it stops

		wait1Msec(10); // mg

	//////////////////
	//
	//		Launcher
	//
	//////////////////

		motor[l1] = 67; // rev launcher up to 67 power
		motor[l2] = 67; // rev launcher up to 67 power
		motor[l3] = 67; // rev launcher up to 67 power
		motor[l4] = 67; // rev launcher up to 67 power

		wait1Msec(3000); // ramp up launcher

		motor[lin] = -127; // outake for (400) Msec to launch first ball
		motor[rin] = -127; // outake for (400) Msec to launch first ball

		wait1Msec(300); // outake

		motor[lin] = 0; // stop outake
		motor[rin] = 0; // stop outake

		wait1Msec(500); // wait 1/2 second

		motor[lin] = -127; // outake second ball
		motor[rin] = -127; // outake second ball

		wait1Msec(300); // wait 7/10 of a second

		motor[lin] = 0; // stop outake
		motor[rin] = 0; // stop outake

		wait1Msec(500); // wait 1/2 second

		motor[lin] = -127; // outake
		motor[rin] = -127; // outake

		wait1Msec(300); // do it for 7/10 second

		motor[lin] = 0; // stop outake
		motor[rin] = 0; // stop outake

		wait1Msec(500); // wait again

		motor[lin] = -127; // outake
		motor[rin] = -127; // outake

		wait1Msec(1000); // turn intake off

		motor[lin] = 0; // stop outake
		motor[rin] = 0; // stop outake
	}
	else{
		displayLCDCenteredString(1, "None");
	}
	displayScreenStyle(MHLCDScreenStyleVoltage);
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
//////////////////////////////////////////////////////////////////////////////////////////
task usercontrol(){
	// User convtrol code here, inside the loop
	displayScreenStyle(MHLCDScreenStyleVoltage);
	while (true){

	  drive(vexRT[Ch3], vexRT[Ch2]);//controller drive
	  int dir = vexRT[Btn5U] ? 1 : vexRT[Btn5D] ? -1 : 0;
	  intakeInDirection(dir);
	  //dir = vexRT[Btn6U] ? 1 : vexRT[Btn6D] ? -1 : 0;
	  if (vexRT[Btn8L] == 1){
	  	shootFly(68);
	  }
	  else if (vexRT[Btn8U] == 1){
	  	shootFly(90);
	  }
		else if (vexRT[Btn8R] == 1){
			shootFly(100);
		}
		else if (vexRT[Btn8D] == 1){
			shootFly(127);
		}
	  else{
	  	shootFly(0);
	  }
	  //launchInDirection(dir);
	}
}
