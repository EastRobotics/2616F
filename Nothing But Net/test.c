#pragma config(Motor,  port1,           lmDrive,       tmotorVex393TurboSpeed_HBridge, openLoop, driveLeft)
#pragma config(Motor,  port2,           lin,           tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           l2,            tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           lfbDrive,      tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           l1,            tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           l3,            tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           rfbDrive,      tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           l4,            tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           rin,           tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          rmDrive,       tmotorVex393TurboSpeed_HBridge, openLoop, reversed, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(0)
#pragma userControlDuration(60)

#include "Vex_Competition_Includes.h"   //Main competition background code...do not modify!


/*
                                			2616F
																Frightening Lighting

												 ___      __    __     __    _______
											  |__ \    / /   /_ |   / /   |   ____|
  												 ) |  / /_    | |  / /_   |  |__
                          / /  | '_ \   | | | '_ \  |   __|
                         / /_  | (_) |  | | | (_) | |  |
                        |____|  \___/   |_|  \___/  |__|
*/


void drive(const short left, const short right){
	if(abs(left) >= 30){
		motor[lfbDrive] = motor[lmDrive] = left; // sets all 3 left drive motors to left
	}
	else{
		motor[lfbDrive] = motor[lmDrive] = 0; // if power is less than 30, stop motors
	}
	if(abs(right) >= 30){
		motor[rfbDrive] = motor[rmDrive] = right; // sets all 3 right drive motors to right
	}
	else{
		motor[rfbDrive] = motor[rmDrive] = 0; // if power is less than 30, stop motors
	}
}

void launchInDirection(const short dir){
	motor[l1] = motor[l2] = motor[l3] = motor[l4] = 127 * dir; // connects the launcher motors to one function and the direction
}

void intakeInDirection(const short dir){
	motor[lin] = motor[rin] = 127 * dir; // connects the intake motors to one function and the direction
}

void shootFly (int speed)
{
	motor[l1] = (speed);
	motor[l2] = (speed);
	motor[l3] = (speed);
	motor[l4] = (speed);
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton(){
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}
/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Autonomous
//
/////////////////////////////////////////////////////////////////////////////////////////


task autonomous()
{
	motor[rfbDrive] = -127; // drive backwards to hit bar infront of the net
	motor[lmDrive] = -127; // drive backwards to hit bar infront of the net
	motor[lfbDrive] = -127; // drive backwards to hit bar infront of the net
	motor[rmDrive] = -127; // drive backwards to hit bar infront of the net

	wait1Msec(3250); // drive backwards

	motor[rfbDrive] = 0; // set all drive = 0 so it stops
	motor[lmDrive] = 0; // set all drive = 0 so it stops
	motor[lfbDrive] = 0; // set all drive = 0 so it stops
	motor[rmDrive] = 0; // set all drive = 0 so it stops

	wait1Msec(10); // take a break

	motor[l1] = 72; // rev launcher up to 67 power
	motor[l2] = 72; // rev launcher up to 67 power
	motor[l3] = 72; // rev launcher up to 67 power
	motor[l4] = 72; // rev launcher up to 67 power

	wait1Msec(3000); // ramp up launcher

	motor[lin] = -127; // outake for (400) Msec to launch first ball
	motor[rin] = -127; // outake for (400) Msec to launch first ball

	wait1Msec(300); // outake

	motor[lin] = 0; // stop outake
	motor[rin] = 0; // stop outake

	wait1Msec(500); // wait 1/2 second

	motor[lin] = -127; // outake second ball
	motor[rin] = -127; // outake second ball

	wait1Msec(300); // wait 7/10 of a second

	motor[lin] = 0; // stop outake
	motor[rin] = 0; // stop outake

	wait1Msec(500); // wait 1/2 second

	motor[lin] = -127; // outake
	motor[rin] = -127; // outake

	wait1Msec(300); // do it for 7/10 second

	motor[lin] = 0; // stop outake
	motor[rin] = 0; // stop outake

	wait1Msec(500); // wait again

	motor[lin] = -127; // outake
	motor[rin] = -127; // outake

	wait1Msec(1000); // final outtake 

	motor[lin] = 0; // stop outake
	motor[rin] = 0; // stop outake

}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
//////////////////////////////////////////////////////////////////////////////////////////
task usercontrol(){
	// User convtrol code here, inside the loop
	displayScreenStyle(MHLCDScreenStyleVoltage);
	while (true){

	  drive(vexRT[Ch3], vexRT[Ch2]);//controller drive
	  int dir = vexRT[Btn5U] ? 1 : vexRT[Btn5D] ? -1 : 0;
	  intakeInDirection(dir);
	  //dir = vexRT[Btn6U] ? 1 : vexRT[Btn6D] ? -1 : 0;
	  if (vexRT[Btn8L] == 1){
	  	shootFly(68);
	  }
	  else if (vexRT[Btn8U] == 1){
	  	shootFly(70);
	  }
		else if (vexRT[Btn8R] == 1){
			shootFly(72);
		}
		else if (vexRT[Btn8D] == 1){
			shootFly(90);
		}
	  else{
	  	shootFly(0);
	  }
	  //launchInDirection(dir);
	}
}
