#pragma config(Motor,  port1,           leftLiftTop,   tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           leftDriveFront, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           leftDriveMiddle, tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port4,           leftDriveBack, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rightDriveFront, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           rightDriveMiddle, tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port7,           rightDriveBack, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           leftLiftBottom, tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port9,           rightLiftTop,  tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          rightLiftBottom, tmotorVex393_HBridge, openLoop, encoderPort, I2C_4)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
This file is the main link of the program, it has the button controls and specific autonomous instructions
*/

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"
#include "ControllerFunctions.c"//Main competition background code...do not modify!
#include "AutonomousFunctions.c"
#include "Selection.c"

void pre_auton()
{

}

task autonomous()
{
//lift for 2 seconds
motor[leftLiftTop] = motor[leftLiftBottom] = motor[rightLiftTop] = motor[rightLiftBottom] = 127;
wait1Msec(2000);
//drive forward for .25 of a second
motor[leftDriveFront]= motor[leftDriveBack] = motor[leftDriveMiddle] = motor[rightDriveBack] = motor[rightDriveFront] = motor[rightDriveMiddle] = 127;
wait1Msec(250);
//lower the lift for .5 of a second
motor[leftLiftTop] = motor[leftLiftBottom] = motor[rightLiftTop] = motor[rightLiftBottom] = -127;
wait1Msec(500);
//drive backward for 1 second
motor[leftDriveFront]= motor[leftDriveBack] = motor[leftDriveMiddle] = motor[rightDriveBack] = motor[rightDriveFront] = motor[rightDriveMiddle] = -127;
wait1Msec(1000);
//lower lift for 1.25 seconds and placing the skyrise in the holder
motor[leftLiftTop] = motor[leftLiftBottom] = motor[rightLiftTop] = motor[rightLiftBottom] = -127;
wait1Msec(1250);
//lifting lift and releasing the skyrise section
motor[leftLiftTop] = motor[leftLiftBottom] = motor[rightLiftTop] = motor[rightLiftBottom] = 127;
wait1Msec(500);
//drive forward for 1.25 seconds
motor[leftDriveFront]= motor[leftDriveBack] = motor[leftDriveMiddle] = motor[rightDriveBack] = motor[rightDriveFront] = motor[rightDriveMiddle] = 127;
wait1Msec(1250);
//lift the lift to get the second skyrise section
motor[leftLiftTop] = motor[leftLiftBottom] = motor[rightLiftTop] = motor[rightLiftBottom] = 127;
wait1Msec(1000);
//lower the lift to get the second skyrise
motor[leftLiftTop] = motor[leftLiftBottom] = motor[rightLiftTop] = motor[rightLiftBottom] = -127;
wait1Msec(750);
//raise the lift with the skyrise section
motor[leftLiftTop] = motor[leftLiftBottom] = motor[rightLiftTop] = motor[rightLiftBottom] = 127;
wait1Msec(1000);
//drive backward to the skyrise
motor[leftDriveFront]= motor[leftDriveBack] = motor[leftDriveMiddle] = motor[rightDriveBack] = motor[rightDriveFront] = motor[rightDriveMiddle] = -127;
wait1Msec(1000);
//lower lift for .750 second and placing the skyrise in the holder
motor[leftLiftTop] = motor[leftLiftBottom] = motor[rightLiftTop] = motor[rightLiftBottom] = -127;
wait1Msec(750);
//lifting lift and releasing the skyrise section
motor[leftLiftTop] = motor[leftLiftBottom] = motor[rightLiftTop] = motor[rightLiftBottom] = 127;
wait1Msec(500);




//	liftLift(1550);
	//wait1Msec(300);
	//nMotorEncoder[leftLiftBottom] = 0;
//	nMotorEncoder[rightLiftBottom] = 0;
//	SensorValue[leftLiftIEM] = 0;
	//SensorValue[rightLifeIEM] = 0;

	//////Drive forward

	//encoderDrive(100, 500);
	//wait1Msec(300);
	//nMotorEncoder[leftDriveMiddle] = nMotorEncoder[rightDriveMiddle] = 0;

	//Release cube
//	SensorValue[intakePneumatics] = 1;

	//LowerLift
	//lowerLift(-1000);
	//wait1Msec(300);
	//nMotorEncoder[leftLiftBottom] = nMotorEncoder[rightLiftBottom] = 0;

	//Grab cube
	//SensorValue[intakePneumatics] = 0;

	//Turn back
	//spin(-60, 800);
	//nMotorEncoder[leftDriveMiddle] = nMotorEncoder[rightDriveMiddle] = 0;

	//Drive forward
	//encoderDrive(60, 500);
	//nMotorEncoder[leftDriveMiddle] = nMotorEncoder[rightDriveMiddle] = 0;

	//Lift lift
	//liftLift(2550);
	//wait1Msec(300);
	//nMotorEncoder[leftLiftBottom] = nMotorEncoder[rightLiftBottom] = 0

	//Release cube
	//SensorValue[intakePneumatics] = 1;
}

task usercontrol()
{
	// User control code here, inside the loop

	while (true)
	{
		//Bogdan Drive
		bool leftDriveShouldStop;
			bool rightDriveShouldStop;

			if(abs(vexRT[Ch3]) <= 30)
				leftDriveShouldStop = true;
			else
				leftDriveShouldStop = false;

			if(abs(vexRT[Ch2]) <= 30)
				rightDriveShouldStop = true;
			else
				rightDriveShouldStop = false;

			if(leftDriveShouldStop)
				motor[leftDriveFront] = motor[leftDriveMiddle] = motor[leftDriveBack] = 0;
			else
				motor[leftDriveFront] = motor[leftDriveMiddle] = motor[leftDriveBack] = vexRT[Ch3];

			if(rightDriveShouldStop)
				motor[rightDriveFront] = motor[rightDriveMiddle] = motor[rightDriveBack] = 0;
			else
				motor[rightDriveFront] = motor[rightDriveMiddle] = motor[rightDriveBack] = vexRT[Ch2];

		//Lift
		if(vexRT[Btn6U]){            //using a the lift function this says run at 127 when 6U is press
			lift(127);
		} else if (vexRT[Btn6D]){       //reverse direction
			lift(-127);
		} else{                     //if neither button is pressed it won't move, it must be set to zero or it'll keep going after being pressed
			lift(0);
		}

		//Intake
		if(vexRT[Btn5U]) {
			//SensorValue[intakePneumatics] = 1;
		} else if(vexRT[Btn5D]) {
			//SensorValue[intakePneumatics] = 0;
		}

	}
}
